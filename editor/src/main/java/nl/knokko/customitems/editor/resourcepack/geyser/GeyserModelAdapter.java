package nl.knokko.customitems.editor.resourcepack.geyser;

import com.github.cliftonlabs.json_simple.JsonException;
import com.github.cliftonlabs.json_simple.JsonObject;
import com.github.cliftonlabs.json_simple.Jsoner;
import nl.knokko.customitems.item.model.GeyserCustomModel;

import java.nio.charset.StandardCharsets;
import java.util.*;

public class GeyserModelAdapter {

    private static JsonObject getJson(JsonObject parent, String key, String description) throws ConversionException {
        Object childObject = parent.get(key);
        if (!(childObject instanceof JsonObject)) {
            throw new ConversionException(description + " object doesn't seem to have " + key + " object");
        }
        return (JsonObject) childObject;
    }

    private static JsonObject getRoot(byte[] bytes, String description) throws ConversionException {
        String text = new String(bytes, StandardCharsets.UTF_8);
        Object rootObject;
        try {
            rootObject = Jsoner.deserialize(text);
        } catch (JsonException invalidJsonFile) {
            throw new ConversionException("Invalid " + description + " file: " + invalidJsonFile.getMessage());
        }
        if (!(rootObject instanceof JsonObject)) {
            throw new ConversionException(description + " file doesn't seem to have a root JSON object");
        }
        return (JsonObject) rootObject;
    }

    public static GeyserCustomModel adaptAutoGenerated(
            String desiredAttachableId, byte[] animationBytes, byte[] attachableBytes,
            byte[] modelBytes, byte[] textureBytes
    ) throws ConversionException {
        return new GeyserModelAdapter(
                desiredAttachableId, animationBytes, attachableBytes, modelBytes, textureBytes
        ).adapt();
    }

    public static ManualResult adaptManuallySelected(
            String desiredAttachableId, byte[] attachableBytes
    ) throws ConversionException {
        JsonObject root = getRoot(attachableBytes, "attachable");
        JsonObject attachable = getJson(root, "minecraft:attachable", "attachable root");

        JsonObject description = getJson(attachable, "description", "attachable");
        description.put("identifier", "geyser_custom:" + desiredAttachableId);

        JsonObject textures = getJson(description, "textures", "attachable description");
        if (textures.containsKey("default")) {
            textures.put("default", "textures/kci/models/" + desiredAttachableId);
        }

        JsonObject geometry = getJson(description, "geometry", "attachable description");
        Object defaultGeometryObject = geometry.get("default");
        if (!(defaultGeometryObject instanceof String)) {
            throw new ConversionException("Geometry object doesn't have a default");
        }

        String newString = Jsoner.prettyPrint(root.toJson());
        byte[] newBytes = newString.getBytes(StandardCharsets.UTF_8);
        return new ManualResult(newBytes, (String) defaultGeometryObject);
    }

    public static class ConversionException extends Exception {

        ConversionException(String message) {
            super(message);
        }
    }

    public static class ManualResult {

        public final byte[] newAttachableBytes;
        public final String geometryId;

        ManualResult(byte[] newAttachableBytes, String geometryId) {
            this.newAttachableBytes = newAttachableBytes;
            this.geometryId = geometryId;
        }
    }

    private final String desiredAttachableId;
    private final byte[] animationBytes, attachableBytes, modelBytes, textureBytes;

    private String lastGeometryId;

    private GeyserModelAdapter(
            String desiredAttachableId, byte[] animationBytes, byte[] attachableBytes,
            byte[] modelBytes, byte[] textureBytes
    ) {
        this.desiredAttachableId = desiredAttachableId;
        this.animationBytes = animationBytes;
        this.attachableBytes = attachableBytes;
        this.modelBytes = modelBytes;
        this.textureBytes = textureBytes;
    }



    private GeyserCustomModel adapt() throws ConversionException {
        JsonObject attachableRoot = getRoot(attachableBytes, "attachable");
        JsonObject attachable = getJson(attachableRoot, "minecraft:attachable", "Root attachable");
        JsonObject attachableDescription = getJson(attachable, "description", "Attachable");

        adaptAttachable(attachableDescription);
        byte[] newGeometryBytes = adaptGeometry(attachableDescription);
        byte[] newAnimationBytes = adaptAnimations(attachableDescription);
        byte[] newAttachableBytes = Jsoner.prettyPrint(attachableRoot.toJson()).getBytes(StandardCharsets.UTF_8);

        return new GeyserCustomModel(
                desiredAttachableId, lastGeometryId, newAnimationBytes,
                newAttachableBytes, newGeometryBytes, textureBytes
        );
    }

    private void adaptAttachable(JsonObject attachableDescriptionJson) throws ConversionException {
        attachableDescriptionJson.put("identifier", "geyser_custom:" + desiredAttachableId);
        JsonObject textures = getJson(attachableDescriptionJson, "textures", "attachable description");
        textures.put("default", "textures/kci/models/" + desiredAttachableId);
    }

    private byte[] adaptAnimations(JsonObject attachableDescriptionJson) throws ConversionException {
        JsonObject animationRoot = getRoot(animationBytes, "animations");
        JsonObject animations = getJson(animationRoot, "animations", "animations root");
        JsonObject attachableAnimations = getJson(attachableDescriptionJson, "animations", "attachable description");

        Set<String> attachableAnimationKeys = new HashSet<>(attachableAnimations.keySet());
        for (String key : attachableAnimationKeys) {
            Object attachableAnimationValue = attachableAnimations.get(key);
            if (!(attachableAnimationValue instanceof String)) {
                throw new ConversionException("Attachable animation " + key + " is not a string");
            }
            String oldAnimationId = (String) attachableAnimationValue;

            Object oldAnimationObject = animations.remove(oldAnimationId);
            if (oldAnimationObject instanceof JsonObject) {
                String newAnimationId = "animation." + desiredAttachableId + "." + key;
                animations.put(newAnimationId, oldAnimationObject);
                attachableAnimations.put(key, newAnimationId);
            }
        }

        return Jsoner.prettyPrint(animationRoot.toJson()).getBytes(StandardCharsets.UTF_8);
    }

    private byte[] adaptGeometry(JsonObject attachableDescriptionJson) throws ConversionException {
        JsonObject geometryRoot = getRoot(modelBytes, "geometry");

        Object geometryObject = geometryRoot.get("minecraft:geometry");
        if (!(geometryObject instanceof List<?>)) {
            throw new ConversionException("Expected minecraft:geometry of geometry JSON to be a list, but got " + geometryObject);
        }
        List<?> geometryList = (List<?>) geometryObject;

        JsonObject attachableGeometry = getJson(attachableDescriptionJson, "geometry", "attachable description");

        Set<String> attachableGeometryKeys = new HashSet<>(attachableGeometry.keySet());
        String lastOldGeometryId = null;
        for (String key : attachableGeometryKeys) {
            Object attachableGeometryValue = attachableGeometry.get(key);
            if (!(attachableGeometryValue instanceof String)) {
                throw new ConversionException("Attachable geometry " + key + " is not a string");
            }
            String oldGeometryId = (String) attachableGeometryValue;
            lastOldGeometryId = oldGeometryId;

            for (Object candidateGeometryObject : geometryList) {
                if (!(candidateGeometryObject instanceof JsonObject)) {
                    throw new ConversionException("Expected geometry list to contain JSON objects, but got " + candidateGeometryObject);
                }
                JsonObject candidateGeometryJson = (JsonObject) candidateGeometryObject;
                JsonObject description = getJson(candidateGeometryJson, "description", "element in geometry list");
                Object identifierObject = description.get("identifier");
                if (!(identifierObject instanceof String)) {
                    throw new ConversionException("Expected identifiers of all geometries to be strings, but got " + identifierObject);
                }
                if (oldGeometryId.equals(identifierObject)) {
                    String newGeometryId = "geometry." + desiredAttachableId + "." + key;
                    attachableGeometry.put(key, newGeometryId);
                    description.put("identifier", newGeometryId);
                    lastGeometryId = newGeometryId;
                }
            }
        }

        if (lastGeometryId == null) lastGeometryId = lastOldGeometryId;
        if (lastGeometryId == null) throw new ConversionException("Attachable doesn't seem to have a single geometry");

        return Jsoner.prettyPrint(geometryRoot.toJson()).getBytes(StandardCharsets.UTF_8);
    }
}
